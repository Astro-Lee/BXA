

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>BXA/Sherpa &mdash; BXA (Bayesian X-ray Analysis) 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="BXA (Bayesian X-ray Analysis) 1.0 documentation" href="index.html" />
    <link rel="prev" title="BXA/Xspec" href="xspec-analysis.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="xspec-analysis.html" title="BXA/Xspec"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">BXA (Bayesian X-ray Analysis) 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="bxa-sherpa">
<h1>BXA/Sherpa<a class="headerlink" href="#bxa-sherpa" title="Permalink to this headline">¶</a></h1>
<p>Define your background model and source model as usual in sherpa.
Freeze the parameters you do not want to investigate. Make sure you set the parameter minimum and maximum values to appropriate (a priori reasonable) values.</p>
<div class="section" id="defining-priors">
<span id="sherpa-priors"></span><h2>Defining priors<a class="headerlink" href="#defining-priors" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># you can use automatic priors (uniform priors everywhere, within the parameters range)</span>
<span class="c"># for this, all scale parameters (those with ampl or norm in their name)</span>
<span class="c"># are converted to log-parameters</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="n">auto_reparametrize</span><span class="p">()</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">bxa</span><span class="o">.</span><span class="n">create_prior_function</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively (advanced), define priors manually:</p>
<div class="highlight-python"><pre># get parameters
parameters = [param1, param2, param3]
# or just get all that are not linked or frozen
parameters = [for p in get_model().pars if not p.frozen and p.link is None]

priors = []
priors += [bxa.create_jeffreys_prior_for(param1)]
priors += [bxa.create_uniform_prior_for(param2)]
priors += [lambda x: x**2] # custom prior transformation (rarely desired)
priorfunction = bxa.create_prior_function(priors = priors)</pre>
</div>
<dl class="function">
<dt id="bxa.sherpa.create_jeffreys_prior_for">
<tt class="descclassname">bxa.sherpa.</tt><tt class="descname">create_jeffreys_prior_for</tt><big>(</big><em>parameter</em><big>)</big><a class="reference internal" href="_modules/bxa/sherpa.html#create_jeffreys_prior_for"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bxa.sherpa.create_jeffreys_prior_for" title="Permalink to this definition">¶</a></dt>
<dd><p>Use for scale variables (order of magnitude)
The Jeffreys prior gives equal weight to each order of magnitude between the
minimum and maximum value. Flat in logarithmic scale.</p>
<p>It is usually easier to create a ancillary Parameter, and make the actual parameter
a function of it, like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sherpa.models.parameter</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="n">lognorm</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">modelname</span><span class="o">=</span><span class="s">&#39;mycomponent&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;lognorm&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=-</span><span class="mi">5</span><span class="p">,</span> <span class="nb">min</span><span class="o">=-</span><span class="mi">4</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">powerlaw</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">lognorm</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="bxa.sherpa.create_uniform_prior_for">
<tt class="descclassname">bxa.sherpa.</tt><tt class="descname">create_uniform_prior_for</tt><big>(</big><em>parameter</em><big>)</big><a class="reference internal" href="_modules/bxa/sherpa.html#create_uniform_prior_for"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bxa.sherpa.create_uniform_prior_for" title="Permalink to this definition">¶</a></dt>
<dd><p>Use for location variables (position)
The uniform prior gives equal weight in non-logarithmic scale.</p>
</dd></dl>

<dl class="function">
<dt id="bxa.sherpa.create_prior_function">
<tt class="descclassname">bxa.sherpa.</tt><tt class="descname">create_prior_function</tt><big>(</big><em>id=None</em>, <em>otherids=()</em>, <em>priors=</em><span class="optional">[</span><span class="optional">]</span>, <em>parameters=None</em><big>)</big><a class="reference internal" href="_modules/bxa/sherpa.html#create_prior_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bxa.sherpa.create_prior_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the prior transformations into a single function for pymultinest.</p>
<p>If priors is empty, uniform priors are used on all passed parameters</p>
</dd></dl>

</div>
<div class="section" id="running-the-analysis">
<span id="sherpa-run"></span><h2>Running the analysis<a class="headerlink" href="#running-the-analysis" title="Permalink to this headline">¶</a></h2>
<p>You need to specify a prefix, called <em>outputfiles_basename</em> where the files are stored.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># see the pymultinest documentation for all options</span>
<span class="n">bxa</span><span class="o">.</span><span class="n">nested_run</span><span class="p">(</span><span class="n">prior</span> <span class="o">=</span> <span class="n">priorfunction</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">,</span>
             <span class="n">resume</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
             <span class="n">outputfiles_basename</span> <span class="o">=</span> <span class="s">&quot;testbxa_&quot;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="function">
<dt id="bxa.sherpa.nested_run">
<tt class="descclassname">bxa.sherpa.</tt><tt class="descname">nested_run</tt><big>(</big><em>id=None</em>, <em>otherids=()</em>, <em>prior=None</em>, <em>parameters=None</em>, <em>sampling_efficiency=0.8</em>, <em>n_live_points=1000</em>, <em>outputfiles_basename='chains/'</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/bxa/sherpa.html#nested_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bxa.sherpa.nested_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the Bayesian analysis with specified prior. 
If prior is None, uniform priors are used on the passed parameters.
If parameters is also None, all thawed parameters are used.</p>
<p>The remainder are multinest arguments (see PyMultiNest and MultiNest documentation!)
outputfiles_basename: prefix to output files
n_live_points: 400 are often enough</p>
</dd></dl>

</div>
<div class="section" id="marginal-plots">
<span id="sherpa-analyse"></span><h2>Marginal plots<a class="headerlink" href="#marginal-plots" title="Permalink to this headline">¶</a></h2>
<p>Plot and analyse the results. PyMultiNest comes in handy at this point to
produce a number of plots and summaries.</p>
<p>On the shell, run:</p>
<div class="highlight-python"><pre>$ multinest_marginals.py "testbxa_"</pre>
</div>
<p>The <a class="reference external" href="https://github.com/JohannesBuchner/PyMultiNest/blob/master/multinest_marginals.py">multinest_marginals.py</a>
utility is installed with PyMultiNest, for instance into ~/.local/bin/.</p>
</div>
<div class="section" id="error-propagation">
<h2>Error propagation<a class="headerlink" href="#error-propagation" title="Permalink to this headline">¶</a></h2>
<p><tt class="xref py py-func docutils literal"><span class="pre">pymultinest.Analyzer.equal_weighted_posterior()</span></tt> provides access to the posterior samples (similar to a Markov Chain).
Use these to propagate errors:</p>
<ul class="simple">
<li>For every row in the chain, compute the quantity of interest</li>
<li>Then, make a histogram of the results, or compute mean and standard deviations.</li>
</ul>
<p>This preserves the structure of the uncertainty (multiple modes, degeneracies, etc.)</p>
<p>You can also access the output directly and compute other quantities:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pymultinest</span>
<span class="n">analyzer</span> <span class="o">=</span> <span class="n">pymultinest</span><span class="o">.</span><span class="n">analyse</span><span class="o">.</span><span class="n">Analyzer</span><span class="p">(</span><span class="n">n_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">),</span>
        <span class="n">outputfiles_basename</span> <span class="o">=</span> <span class="s">&#39;testbxa_&#39;</span><span class="p">)</span>

<span class="n">chain</span> <span class="o">=</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">get_equal_weighted_posterior</span><span class="p">()</span>

<span class="k">print</span> <span class="n">chain</span>
</pre></div>
</div>
<p>BXA also allows you to compute the fluxes corresponding to the
parameter estimation, giving the correct probability distribution on the flux.
With distance information (fixed value or distribution), you can later infer
the correct luminosity distribution.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dist</span> <span class="o">=</span> <span class="n">pyblocxs</span><span class="o">.</span><span class="n">mn</span><span class="o">.</span><span class="n">get_distribution_with_fluxes</span><span class="p">(</span><span class="n">lo</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">hi</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">outputfiles_basename</span> <span class="o">=</span> <span class="s">&#39;testbxa_&#39;</span><span class="p">)</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s">&quot;dist.txt&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
</pre></div>
</div>
<dl class="function">
<dt id="bxa.sherpa.get_distribution_with_fluxes">
<tt class="descclassname">bxa.sherpa.</tt><tt class="descname">get_distribution_with_fluxes</tt><big>(</big><em>id=None</em>, <em>otherids=()</em>, <em>lo=None</em>, <em>hi=None</em>, <em>parameters=None</em>, <em>outputfiles_basename='chains/'</em><big>)</big><a class="reference internal" href="_modules/bxa/sherpa.html#get_distribution_with_fluxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bxa.sherpa.get_distribution_with_fluxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of equally weighted posterior samples (parameter values) with two 
additional columns: the photon fluxes and the energy fluxes.</p>
<p>The values will be correctly distributed according to the
analysis run before.</p>
</dd></dl>

</div>
<div class="section" id="model-comparison">
<span id="sherpa-models"></span><h2>Model comparison<a class="headerlink" href="#model-comparison" title="Permalink to this headline">¶</a></h2>
<p><em>examples/model_compare.py</em> shows an example of model selection. Keep in mind what model prior you would like to use.</p>
<ul>
<li><dl class="first docutils">
<dt>Case 1: Multiple models, want to find one best one to use from there on:</dt>
<dd><ul class="first last simple">
<li>follow <em>examples/model_compare.py</em>, and pick the model with the highest evidence</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Case 2: Simpler and more complex models, want to find out which complexity is justified:</dt>
<dd><ul class="first last simple">
<li>follow <em>examples/model_compare.py</em>, and keep the models above a certain threshold</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Case 3: Multiple models which could be correct, only interested in a parameter</dt>
<dd><ul class="first last simple">
<li>Marginalize over the models: Use the posterior samples from each model, and weigh them by the
relative probability of the models (weight = exp(lnZ))</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Example output:</p>
<div class="highlight-python"><pre>jbuchner@ds42 $ python model_compare.py absorbed- line- simplest-

Model comparison
****************

model simplest- : log10(Z) = -1632.7  XXX ruled out
model absorbed- : log10(Z) =    -7.5  XXX ruled out
model line-     : log10(Z) =     0.0    &lt;-- GOOD

The last, most likely model was used as normalization.
Uniform model priors are assumed, with a cut of log10(30) to rule out models.

jbuchner@ds42 $</pre>
</div>
<p>Here, the probability of the second-best model, &#8220;absorbed&#8221;, is <span class="math">\(10^7.5\)</span> times
less likely than the model &#8220;line&#8221;. As this exceeds our threshold (by a lot!)
we can claim the detection of an iron line!</p>
</div>
<div class="section" id="experiment-design">
<span id="sherpa-design"></span><h2>Experiment design<a class="headerlink" href="#experiment-design" title="Permalink to this headline">¶</a></h2>
<p>We want to to evaluate whether a planned experiment can detect features or constrain parameters,
i.e. determine the discriminatory power of future configurations/surveys/missions.</p>
<p>For this, simulate a few spectra using the appropriate response.</p>
<ul>
<li><dl class="first docutils">
<dt>Case 1: Can the experiment constrain the parameters?</dt>
<dd><ul class="first last simple">
<li>Analyse and check what fraction of the posterior samples lie inside/outside the region of interest.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Case 2: Can the experiment distinguish between two models?</dt>
<dd><ul class="first last simple">
<li>Model selection as above.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Case 3: Which sources (redshift range, luminosity, etc) can be distinguished?</dt>
<dd><ul class="first last simple">
<li>Compute a grid of spectra. Do model selection at each point in the grid.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="model-discovery">
<span id="sherpa-qq"></span><h2>Model discovery<a class="headerlink" href="#model-discovery" title="Permalink to this headline">¶</a></h2>
<p>Is the model the right one? Is there more in the data? These questions can not
be answered in a statistical way, <strong>but</strong> what we can do is</p>
<ol class="arabic simple">
<li>generate ideas on what models could fit better</li>
<li>test those models for significance with model selection</li>
</ol>
<p>For the first point, <strong>Quantile-Quantile plots</strong> provide a unbinned, less noisy alternative to
residual plots.</p>
<img alt="_images/absorbed-qq_model_deviations1.png" src="_images/absorbed-qq_model_deviations1.png" />
<img alt="_images/absorbed-convolved_posterior1.png" src="_images/absorbed-convolved_posterior1.png" />
<p>QQ plot example (left), with the corresponding spectrum for comparison (right).</p>
<p>In these plots, for each energy the number of counts observed with lower energy
are plotted on one axis, while the predicted are on the other axis.
If model and data agree perfectly, this would be a straight line.
Deviances are indications of possible mis-fits.</p>
<p>This example is almost a perfect fit!
You can see a offset growing at 6-7 keV, which remains at higher energies.
This indicates that the data has more counts than the model there.</p>
<p>As the growth is in a S-shape, it is probably a Gaussian (see its <a class="reference external" href="https://en.wikipedia.org/wiki/Normal_distribution">cumulative density function</a>).</p>
<p>Refer to the appendix of the <a class="reference external" href="cite">accompaning paper</a> for more examples.</p>
<p>The <em>qq</em> function in the <em>qq</em> module allows you to create such plots easily.</p>
<span class="target" id="module-bxa.xspec.qq"></span><p>Statistics and Plotting for quantile-quantile analysis for model discovery</p>
<dl class="function">
<dt id="bxa.xspec.qq.qq">
<tt class="descclassname">bxa.xspec.qq.</tt><tt class="descname">qq</tt><big>(</big><em>analyzer</em>, <em>markers=5</em>, <em>annotate=True</em><big>)</big><a class="reference internal" href="_modules/bxa/xspec/qq.html#qq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bxa.xspec.qq.qq" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a quantile-quantile plot for model discovery (deviations in data from model).</p>
<p>The current data and model is used, so call <em>set_best_fit(analyzer, transformations)</em>
before, to get the qq plot at the best fit.</p>
<ul class="simple">
<li>markers: list of energies/channels (whichever the current plotting xaxis unit)</li>
</ul>
<p>or number of equally spaced markers between minimum+maximum.
* annotate: add information to the plot</p>
</dd></dl>

<p>Refer to the <a class="reference internal" href="index.html#cite"><em>accompaning paper</em></a>, which gives an introduction and
detailed discussion on the methodology.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">BXA/Sherpa</a><ul>
<li><a class="reference internal" href="#defining-priors">Defining priors</a></li>
<li><a class="reference internal" href="#running-the-analysis">Running the analysis</a></li>
<li><a class="reference internal" href="#marginal-plots">Marginal plots</a></li>
<li><a class="reference internal" href="#error-propagation">Error propagation</a></li>
<li><a class="reference internal" href="#model-comparison">Model comparison</a></li>
<li><a class="reference internal" href="#experiment-design">Experiment design</a></li>
<li><a class="reference internal" href="#model-discovery">Model discovery</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="xspec-analysis.html"
                        title="previous chapter">BXA/Xspec</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/sherpa-analysis.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="xspec-analysis.html" title="BXA/Xspec"
             >previous</a> |</li>
        <li><a href="index.html">BXA (Bayesian X-ray Analysis) 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Johannes Buchner.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>